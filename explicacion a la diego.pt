He incluido una interfaz Sorter simulada para que el código compile y funcione; luego conectarás ahí los algoritmos de tus compañeros.

1. Generador de Datos (Responsabilidad #3)
Esta clase estática se encarga de crear los arreglos y listas según tus especificaciones.

Java

import java.util.ArrayList;
import java.util.Random;

public class DataGenerator {
    private static final Random random = new Random();

    public static int[] generateRandomArray(int size) {
        int[] data = new int[size];
        for (int i = 0; i < size; i++) {
            data[i] = random.nextInt(1000000); // Números aleatorios
        }
        return data;
    }

    public static int[] generateRangeArray(int size, int min, int max) {
        int[] data = new int[size];
        for (int i = 0; i < size; i++) {
            data[i] = random.nextInt(max - min + 1) + min;
        }
        return data;
    }

    // Versión para ArrayList
    public static ArrayList<Integer> generateRandomArrayList(int size) {
        ArrayList<Integer> list = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            list.add(random.nextInt(1000000));
        }
        return list;
    }
}
2. Clase del Hilo de Trabajo (Responsabilidad #2 y #4)
Esta clase maneja el ciclo de vida, la medición de tiempos (currentTimeMillis) y el reporte de estadísticas.

Java

import java.util.Arrays;
import java.util.HashMap;

// Interfaz simple para que el Integrante B conecte sus algoritmos aquí después
interface Sorter {
    void sort(int[] data);
    String getName();
}

public class SortThread extends Thread {
    // Flag volátil para asegurar que todos los hilos vean el cambio de estado inmediatamente
    private volatile boolean running = true; 
    
    private Sorter algorithm;
    private HashMap<String, String> resultsMap; // Referencia al mapa global
    
    // Contadores locales
    private long totalSorts = 0;
    private long totalTime = 0;

    public SortThread(Sorter algorithm, HashMap<String, String> resultsMap) {
        this.algorithm = algorithm;
        this.resultsMap = resultsMap;
    }

    @Override
    public void run() {
        while (running) {
            // 1. Generamos datos (Alternamos tamaños para cubrir el requisito)
            // En un caso real, podrías crear un hilo por tamaño, aquí rotamos para el ejemplo
            int[] data100 = DataGenerator.generateRandomArray(100);
            processSort(data100);
            if (!running) break;

            int[] data50k = DataGenerator.generateRandomArray(50000);
            processSort(data50k);
            if (!running) break;

            int[] data100k = DataGenerator.generateRandomArray(100000);
            processSort(data100k);
            if (!running) break;
            
            int[] dataRange = DataGenerator.generateRangeArray(100000, 1, 5);
            processSort(dataRange);
        }
        
        // Guardar resultados finales en el mapa compartido
        saveResults();
    }

    private void processSort(int[] data) {
        long start = System.currentTimeMillis();
        algorithm.sort(data);
        long end = System.currentTimeMillis();
        
        totalTime += (end - start);
        totalSorts++;
    }

    public void stopThread() {
        this.running = false;
    }

    private void saveResults() {
        double avgTime = totalSorts > 0 ? (double) totalTime / totalSorts : 0;
        String stats = String.format("Total: %d | Avg Time: %.2f ms", totalSorts, avgTime);
        
        // Sincronización necesaria porque varios hilos escribirán en el mapa
        synchronized (resultsMap) {
            resultsMap.put(algorithm.getName(), stats);
        }
    }
}
3. Clase Principal / Main (Responsabilidad #1 y #5)
Orquesta la entrada del usuario, el tiempo límite y la impresión final.

Java

import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

public class MainConcurrency {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        HashMap<String, String> finalResults = new HashMap<>();

        // 1. Pedir tiempo límite
        System.out.println("=== SISTEMA DE ORDENAMIENTO CONCURRENTE ===");
        System.out.print("Ingrese el tiempo límite de ejecución (segundos): ");
        int timeSeconds = scanner.nextInt();
        long timeMillis = timeSeconds * 1000L;

        // 2. Definir algoritmos (Aquí simulo dos, pero aquí irían los del Integrante B)
        Sorter bubbleSimulator = new Sorter() {
            public void sort(int[] data) { Arrays.sort(data); } // Simulación
            public String getName() { return "BubbleSort-Simulado"; }
        };

        Sorter quickSimulator = new Sorter() {
            public void sort(int[] data) { Arrays.sort(data); } // Simulación
            public String getName() { return "QuickSort-Simulado"; }
        };

        // 3. Crear e Iniciar Hilos
        SortThread thread1 = new SortThread(bubbleSimulator, finalResults);
        SortThread thread2 = new SortThread(quickSimulator, finalResults);

        System.out.println("--> Iniciando hilos...");
        thread1.start();
        thread2.start();

        // 4. Controlar el tiempo de ejecución (Main Thread duerme)
        try {
            Thread.sleep(timeMillis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 5. Detener hilos
        System.out.println("--> Tiempo agotado. Deteniendo hilos...");
        thread1.stopThread();
        thread2.stopThread();

        // Esperar a que terminen limpiamente (join)
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 6. Consola / Salida final (Responsabilidad #5)
        System.out.println("\n============== RESULTADOS FINALES ==============");
        System.out.println(String.format("%-25s | %s", "Algoritmo", "Estadísticas"));
        System.out.println("------------------------------------------------");
        
        for (String key : finalResults.keySet()) {
            System.out.println(String.format("%-25s | %s", key, finalResults.get(key)));
        }
        System.out.println("================================================");
    }
}